
from platform import java_ver
import sys
input = sys.stdin.readline


#================================================================================================================================================================


"""  10872번 - 팩토리얼
; N이 주어졌을 때 N!을 재귀함수를 통해 계산하기 (0 ≤ N)
; 예를 들어 N이 4일 때 아래 fac 함수에 4를 전달해주면...
재귀적 호출을 통해 결국 fac(0) * 1 * 2 * 3 * 4 의 값을 반환하게 됨 (결과는 24)  """

def _10872():
    N = int(input()) # 첫째줄: N!을 계산할 정수 하나
    
    def fac(N):
        if N == 0:
            return 1 # 0!은 1로 약속됨
        else: 
            return (fac(N-1) * N) # 하나 작은 수까지의 팩토리얼에 현재 수를 곱하는 과정을 계속해서 반복
    
    print(fac(N)) # 둘째줄: N!을 계산한 결과


#================================================================================================================================================================


"""  10870번 - 피보나치 수 5
; n이 주어졌을 때 n번째 피보나치 수를 재귀함수를 통해 계산하기 (0 ≤ n ≤ 20)
n번째 피보나치 수를 Fn이라 하자 -> F0 = 0, F1 = 1 -> F0부터 순서대로 0 1 1 2 3 5 8 13 21...
; 예를 들어 N이 4일 때 아래 fibo 함수에 4를 전달해주면...
재귀적 호출을 통해 결국 F3 + F2 = (F2 + F1) + (F1 + F0) = (fibo(1) + fibo(0) + fibo(1)) + (fibo(1) + fibo(0)) 의 값을 반환하게 됨 (결과는 3)  """

def _10870():
    n = int(input()) # 첫째줄: Fn을 계산할 정수 하나
    
    def fibo(n):
        if n == 0:
            return 0 # F0은 0으로 약속됨
        elif n == 1:
            return 1 # F1은 1로 약속됨
        else:
            return (fibo(n-1) + fibo(n-2)) # 그 전의 피보나치 수와 그 전 전의 피보나치 수를 구해서 더하는 과정을 계속해서 반복

    print(fibo(n)) # 둘째줄: Fn을 계산한 결과


#================================================================================================================================================================


"""  17478번 - 재귀함수가 뭔가요?
; N은 응답을 반복할 횟수 -> 전체적으로 N번 물어보고 N번 다른 대답하고 N+1번째 물어봤을 때 진짜로 재귀함수가 뭔지 말해주고 끝남
1번 문장: 어느 한 ~ -> 이게 시작이니까 처음에 1번만 출력
2번 문장: 재귀함수가~ -> 물어보는 건 총 N+1번이니까 N+1번 출력
3번 문장: 잘 들어보게~ -> 가짜 대답은 N번 출력
4번 문장: 재귀함수는~ -> 진짜 대답은 마지막에 1번만 출력
5번 문장: 라고 답변~ -> 총 N+1번 물어봤으니까 답변했다는 말도 N+1번 출력
; 2번~5번은 반복할 때마다 문장 앞에 ____ 4개씩 붙여나감 (특히 3번은 전체 아니고 '각' 문장 앞에 붙이는 거)  """

def _17478():
    N = int(input()) # 첫째줄: 응답을 반복할 횟수
        
    def reply(tmp):
        s1 = "\"재귀함수가 뭔가요?\""
        s2 = "\"잘 들어보게. 옛날옛날 한 산 꼭대기에 이세상 모든 지식을 통달한 선인이 있었어."
        s3 = "마을 사람들은 모두 그 선인에게 수많은 질문을 했고, 모두 지혜롭게 대답해 주었지."
        s4 = "그의 답은 대부분 옳았다고 하네. 그런데 어느 날, 그 선인에게 한 선비가 찾아와서 물었어.\""
        s5 = "\"재귀함수는 자기 자신을 호출하는 함수라네\""
        s6 = "라고 답변하였지."
        underbar = "____"

        # 예를 들어 N이 2라면...
        print(underbar * (N - tmp) + s1) # tmp가 2일 때, tmp가 1일 때, tmp가 0일 때 -> 총 3번으로 N+1번 출력 성공
        
        # tmp가 0일 때 -> 마지막에 1번만 출력 성공
        if tmp == 0:
            print(underbar * (N - tmp) + s5)
            print(underbar * (N - tmp) + s6)
            return
        
        # tmp가 2일 때, tmp가 1일 때 -> 총 2번으로 N번 출력 성공
        print(underbar * (N - tmp) + s2)
        print(underbar * (N - tmp) + s3)
        print(underbar * (N - tmp) + s4)

        reply(tmp - 1) # 처음에 N을 옮겨담은 다음 0이 될 때까지 반복
        
        print(underbar * (N - tmp) + s6) # 이게 순서가 먼저 가짜 대답을 출력하고 나서 답변했다는 말을 출력해야 함
            
    print("어느 한 컴퓨터공학과 학생이 유명한 교수님을 찾아가 물었다.") # 둘째줄: 챗봇의 시작
    reply(N) # 셋째줄부터: 챗봇의 응답    
    

#================================================================================================================================================================


"""  2447번 - 별 찍기 10
; N이 주어졌을 때 일정한 규칙에 따라 NxN 크기의 *로 구성된 패턴을 출력하기
; 그 규칙이 뭐냐면... (일단 N은 3의 거듭제곱 형태로 늘어남)
N이 3일 때는 맨 왼쪽 패턴 -> N이 9일 때는 9x9 크기를 9등분해서 저 패턴으로 가득 채운 후 가운데만 없앰
-> N이 27일 때는 역시나 27x27 정사각형 9등분 후 이전 패턴을 9번 갖다박고 가운데만 뻥 뚫음
              *********
              * ** ** * 
              *********
***          ***    ***
* *    ->    * *     * *    ->    how to solve?
***          ***    ***
              *********
              * **  ** *
              *********
1. 리스트 2개를 준비 
raw = 최초에는 N이 3일 때의 패턴을 저장 (이후 업데이트) 
new = N이 3보다 클 때 raw를 가지고 만들어낸 새 패턴을 저장 (이걸 반환)
2. 패턴은 위에서부터 3행씩 나눠서 반복문 3개 돌려서 만들기
예를 들어 N = 9, raw = [***, '\n', * *, '\n', ***]
- 1행~3행 만들기: raw에서 각 행에 해당하는 패턴을 3배씩 늘려서 new에 추가
그러면 new에는 [*********, '\n', * ** ** *, '\n', *********]
- new에 '\n' 추가하기
- 4행~6행 만들기: 역시나 raw에서 개행문자가 아닌 요소들만 3배씩 늘려서 new에 추가 (근데 중간 3칸은 공백으로)
그러면 new에는 [1행~3행, 개행문자 하나, ***   ***, '\n', * *   * *, '\n', ***   ***]
- new에 '\n' 추가하기
- 7행~9행 make: 첫번째와 동일
재귀함수를 통해 raw를 N이 3일때의 패턴 -> N이 9일 때의 패턴 -> ... 계속 업데이트해서 최종적으로 입력받은 N일 때의 패턴까지 만들기
3. 반환된 리스트에 들어있는 모든 요소들을 출력해주면 끝 -> for문으로 하나씩 꺼내서 말고 join 함수로 이어서?  """

def _2447():
    N = int(input()) # 첫째줄: 패턴(정사각형) 한 변의 길이
    
    def pattern(tmp):
        
        raw = ['***', '\n', '* *', '\n', '***'] # 현재는 N이 3일 때의 패턴
        new = [] # N이 3보다 클 때의 패턴
                
        if tmp == 3: # N이 3이면 그냥 raw를 반환해주면 됨
            return raw
        
        else:
            raw = pattern(tmp//3) # 재귀함수를 통해 업데이트
            print(''.join(raw))
            
            for i in raw:
                if i == '\n': # 개행문자는 늘리지 않고 하나만 추가
                    new.append(i)
                else:
                    new.append(i * 3) # 1행~3행의 패턴은 늘려서 추가
            
            new.append('\n') # 3행에서 4행으로 넘어가기 위함
            
            for i in raw:
                if i == '\n': # 개행문자는 늘리지 않고 하나만 추가
                    new.append('\n')
                else:
                    new.append(i + ' ' * (tmp//3) + i) # 4행~6행의 패턴은 늘려서 추가
            
            new.append('\n') # 6행에서 7행으로 넘어가기 위함
            
            for i in raw:
                if i == '\n': # 개행문자는 늘리지 않고 하나만 추가
                    new.append(i)
                else:
                    new.append(i * 3) # 7행~9행의 패턴은 늘려서 추가
                    
            return new

    res = ''.join(pattern(N)) # 리스트에 저장된 모든 문자열들을 연결
    print(res) # 둘째줄부터: 만든 패턴을 출력


#================================================================================================================================================================


"""  11729번 - 하노이 탑 이동 순서
; 첫번째 장대에 쌓여있는 모든 원반을 세번째 장대로 이동하는 데 필요한 최소 횟수는? (근데 어떻게 이동하는지도 출력해야 함)
N은 주어진 원반의 개수 -> 원반은 하나씩만 이동, 쌓을 때는 위가 아래보다 더 작아야 함
K는 그렇게 구한 최소 횟수 -> 이 밑에부터 총 K번의 이동 양상을 A B 형태로 출력
(예를 들어 1 3 이면 첫번째 장대에 쌓여있는 원반들 중 맨 위의 원반을 세번째 장대로 이동시켰다는 뜻)
; 어떤 규칙으로 옮길까...
N-1개의 원판을 두번째 장대로 -> 1개의 원판을 세번째 장대로 -> n-1개의 원판을 세번째 장대로
; 그리고 최소 이동횟수는...
T1 = 1, Tn = 2Tn-1 + 1 -> Tn = 2^n -1 로 알려져 있음 -> 그냥 2**n - 1 바로 출력?  """

def _11729():
    N = int(input()) # 첫째줄: 첫번째 장대에 쌓여있는 원반의 개수
    
    def move(num, start, end): # 차례대로 원반의 개수, 옮기기 전 장대, 옮기게 될 장대 (그니까 start번째 장대에서 end번째 장대로)
        if num == 1: # 원반이 하나만 남으면 첫번째에서 세번째로 옮기고 끝임
            print(start, end) # 이동 양상도 출력해야 함
            return
        
        mid = 6 - start - end
        
        move(N-1, start, mid) # N-1개의 원반을 첫번째에서 두번째로 옮김
        print(start, end) # 이동 양상도 출력해야 함
        move(N-1, mid, end) # 이게 맞나........?
    
    print(2**N - 1) # 둘째줄: 세번째 장대로 모두 옮기는 최소 이동횟수 (2^N - 1로 알려져 있음)
    move(N, 1, 3)


#================================================================================================================================================================


"""  2798번 - 블랙잭
; N장의 카드가 주어짐 (최소 3장 최대 100장) -> 여기서 3장을 뽑아서 모두 더함 -> M을 넘지 않으면서 최대한 가깝게 만들어야 함 -> 어떤 3장을 뽑으면 될까? 이때 실제로 그들의 합은?
; 서로 다른 N개에서 순서 상관없이 3개를 뽑는 경우의 수는 NC3 -> 3중 for문 돌려서 총 NC3번의 합을 검사
정확히 뭘 반복하냐면... 새로운 카드 3장의 합을 구함 -> 이게 M을 안 넘으면 이전까지의 최댓값과 비교 -> 더 큰 값을 기록해나감  """

def _2798():
    N, M = map(int, input().split()) # 첫째줄: 카드의 개수, 타겟의 숫자
    card_list = list(map(int, input().split())) # 둘째줄: 카드에 적혀있는 숫자들
    sum = 0 # 3중 for문으로 한번씩 구한 카드 3장의 합 (총 NC3번)
    res = 0 # 타겟을 넘지 않으면서 가장 가까운 합을 기록
    
    for i in range(N):
        for j in range(i + 1, N):
            for k in range(j + 1, N):
                sum = card_list[i] + card_list[j] + card_list[k] # 이번 차례의 카드 3장의 합
                if sum <= M: # 이게 타겟을 안 넘는다면 이전까지의 최댓값과 비교해서 업데이트
                    res = max(res, sum)
    
    print(res) # 셋째줄: 그렇게 구한 최댓값


#================================================================================================================================================================


"""  2231번 - 분해합
; N의 생성자가 M이다 == N은 M의 분해합이다 -> 그러니까 어떤 수 M이 있는데, M과 M의 각 자리수를 더한 게 N이라면, M을 N의 생성자라고 함
N의 생성자는 여러개일 수 있음 -> 256 = 245 + 2 + 4 + 5 = ...
N의 생성자는 없을 수 있음 -> 그렇게 더해서 특정 수가 안될 수도...
; N의 가장 작은 생성자를 출력 (없으면 0을 출력)
그럼 그냥 1부터 N까지 루프 돌리면서 -> 매번 분해합 구해서 -> 둘이 같으면 그 수를 출력하고 끝 -> 한번도 안 같았으면 없는거니까 0을 출력
분해합은 어떻게? str으로 만들어서 -> 문자 하나하나 리스트에 추가해놓고 -> map 함수로 하나하나 int로 바꿔서 다시 저장 -> sum 함수에 넣고 이번 차례 수까지 더해주면 됨
이번 차례에 123을 검사한다면... str(123) -> tmp = ['1', '2', '3'] -> tmp = list(map(int, tmp)) -> 123 + sum(tmp)  """

def _2231():
    N = int(input()) # 첫째줄: 가장 작은 생성자를 구할 수
    
    for i in range(1, N + 1): # 가장 작은 생성자니까 1부터 찾기 시작
        
        tmp = [j for j in str(i)] # 각 자리수를 더하기 위해 하나하나 리스트에 추가시켜놓음 (아직은 문자열)
        
        tmp = list(map(int, tmp)) # 정수로 바꿔줌
        
        if i + sum(tmp) == N: # 이번 차례의 수와 그의 각 자리수까지 모두 더함 -> 이게 이번 차례의 수가 되면 생성자 맞음
            print(i) # 둘째줄: 이를 출력하면 끝
            return
        
    print(0) # 둘째줄: N까지 검사했는데 없으면 0을 출력
    
    
#================================================================================================================================================================


"""  7568번 - 덩치
; 몸무게가 xkg, 키가 ycm -> 덩치는 (x, y)로 표현 -> x도 크고 y도 커야 덩치가 큼, 둘 중 하나라도 작으면 안됨
(56, 177) > (45, 165) / (56, 177) ? (45, 180)
; 덩치로 등수를 매겨서 출력 -> 자기보다 덩치가 큰(키도 크고 몸무게도 큰) 사람이 k명이면 자신의 등수는 k+1
덩치가 큰 사람만 세서 정하는 거니까 -> 1등부터 차례대로 매겨지는게 아님, 등수는 중복될 수도 있음
; 등수를 기록할 변수 준비 -> 일단 1부터 시작 (자기보다 덩치가 큰 사람이 없으면 자기가 1등) -> 이중? 루프로 두 사람의 덩치 꺼냄 -> 몸무게랑 키 하나씩 비교해서 등수 매김  """

def _7568():
    N = int(input()) # 첫째줄: 덩치로 등수를 매길 사람의 수
    person_list = [tuple(map(int, input().split())) for _ in range(N)] # 둘째줄부터: 각 사람의 덩치
    count = 0 # 자기보다 덩치가 큰 사람의 수

    for p1 in person_list: # p1은 튜플의 형태
        count = 1 # 덩치가 큰 사람이 없으면 자기가 1등
        for p2 in person_list: # p2도 튜플의 형태
            if (p1[0] < p2[0] and p1[1] < p2[1]): # 몸무게도 크고 키도 크면 등수+1
                count += 1
        print(count, end=' ')


#================================================================================================================================================================


##### 미해결
"""  1018번 - 체스판 다시 칠하기
; MxN 체스판이 각 칸마다 W 또는 B으로 무작위로 칠해져 있음 -> 8x8 체스판으로 잘라서 몇 칸 정도 다시 칠해서 전체적으로 WBWB... 또는 BWBW... 이런 패턴으로 만들거임 -> 이때 다시 칠해야하는 칸의 최수 개수는?
일단 8x8로 자르는 건 고정, 그렇게 잘라놓고 몇 개를 다시 칠해야 번갈아가는 패턴이 될까
그럼 그냥 [0][0]부터 [N-1][M-1]까지 범위 잡고 8x8로 한번씩 다 잘라서 몇 개 칠해야하는지 다 구해놓고 최종적으로 젤 적게 카운트된 개수 출력?
; 
;
"""

def _1018():
    N, M = map(int, input().split()) # 첫째줄: 주어진 체스판의 크기 (한 행은 M칸, 그런 행이 N개, 총 MxN칸)
    
    board = [] # 밑의 과정을 거치면 이차원 리스트가 됨 (총 N개의 요소, 각 요소마다 다시 또 M개의 요소)
    
    for i in range(N): # 둘째줄부터: 주어진 체스판의 패턴 (W과 B이 무작위로 칠해져 있음)
        tmp = list(input()[:-1]) # 맨뒤에 개행문자는 제외 -> 연속적인 WBWBB...들을 하나씩 쪼개서 리스트에 저장 -> 그 리스트를 최종적으로 board에 추가
        board.append(tmp)

    
    B_board = \
    [   ['B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'],
        ['W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'],
        ['B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'],
        ['W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'],
        ['B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'],
        ['W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'],
        ['B', 'W', 'B', 'W', 'B', 'W', 'B', 'W']    ]
    
    W_board = \
    [   ['W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'],
        ['B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'],
        ['W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'],
        ['B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'],
        ['W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'],
        ['B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'],
        ['W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'],   ]
    

    # B_count = 0 # BWBW... 패턴인 경우 몇 개를 다시 칠할지
    # W_count = 0 # WBWB... 패턴인 경우 몇 개를 다시 칠할지    
    
    # for i in range(8):
    #     for j in range(8):

    #         if board[][] != B_board[][]:
    #             B_count += 1
    #         if board[][] != W_board[][]:
    #             W_count += 1


#================================================================================================================================================================


"""  1436번 - 영화감독 숌
; 시리즈 영화의 제목을 짓는 규칙 -> 맨뒤에 종말의 수 하나를 붙임 (예를 들어 '세상의 종말 666')
종말의 수란 6이 적어도 3개 이상 연속으로 들어가는 수 -> 666 1666 2666 3666 ...
N번째 영화 제목에 붙게되는 종말의 수는? 다시 말해 N번째로 큰 종말의 수는?
; 1부터 하나씩 증가시킴 -> 매번 str으로 만들어서 '666' 있는지 확인 -> 있으면 종말의 수
그렇게 찾을 때마다 횟수 하나식 카운트 -> 또 하나의 종말의 수를 찾았는데 횟수가 N과 같아졌으면 -> 이를 출력하고 종료  """

def _1436():
    N = int(input()) # 첫째줄: 몇 번째로 큰 종말의 수를 구할건지
    
    number = 0 # 종말의 수를 저장
    count = 0 # 현재 몇 번째 종말의 수를 구한건지 기록
    
    while True:
        if '666' in str(number): # 종말의 수가 맞는지 검사
            count += 1
            if count == N: # N번째 종말의 수를 구한게 맞으면
                print(number) # 이를 출력하고 종료
                break
        number += 1 # 아니면 계속해서 1씩 키워나감


#================================================================================================================================================================

