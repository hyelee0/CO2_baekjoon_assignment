import sys
input = sys.stdin.readline


#================================================================================================================================================================


"""  1085번 - 직사각형에서 탈출  """

def _1085():
    x, y, w, h = map(int, input().split()) # 입력: 현재 위치의 x좌표, y좌표 / 직사각형 오른쪽 위 꼭짓점의 x좌표, y좌표

    # 현재 (0, 0)으로부터 (+x, +y)만큼 와 있으니, x만큼 백하던지 w-x만큼 고하던지 or y만큼 백하던지 h-y만큼 고하던지
    distance_list = [x, y, w-x, h-y]

    print(min(distance_list)) # 출력: 현재 위치에서 경계선까지 가는 거리의 최솟값을 출력


#================================================================================================================================================================


"""  4153번 - 직각삼각형   """

def _4153():
    while True:
        a, b, c = map(int, input().split()) # 입력: 세 변의 길이
        if a == b == c == 0:
            break
        
        # 세 변이 오름차순으로 주어진다는 보장 X -> 세 변 중 가장 긴 변을 찾아야 함, 나머지 두 변도 각각 분리시켜야 함
        max_length, min_length = max(a, b, c), min(a, b, c)
        mid_length = a+b+c - max_length - min_length
        
        # 출력: 직각삼각형 해당여부를 출력
        if max_length**2 == mid_length**2 + min_length**2:
            print('right')
        else:
            print('wrong')


#================================================================================================================================================================


"""  2231번 - 분해합
; N의 생성자가 M이다 == N은 M의 분해합이다 -> 그러니까 어떤 수 M이 있는데, M과 M의 각 자리수를 더한 게 N이라면, M을 N의 생성자라고 함
N의 생성자는 여러개일 수 있음 -> 256 = 245 + 2 + 4 + 5 = ...
N의 생성자는 없을 수 있음 -> 그렇게 더해서 특정 수가 안될 수도...
; N의 가장 작은 생성자를 출력 (없으면 0을 출력)
그럼 그냥 1부터 N까지 루프 돌리면서 -> 매번 분해합 구해서 -> 둘이 같으면 그 수를 출력하고 끝 -> 한번도 안 같았으면 없는거니까 0을 출력
분해합은 어떻게? str으로 만들어서 -> 문자 하나하나 리스트에 추가해놓고 -> map 함수로 하나하나 int로 바꿔서 다시 저장 -> sum 함수에 넣고 이번 차례 수까지 더해주면 됨
이번 차례에 123을 검사한다면... str(123) -> tmp = ['1', '2', '3'] -> tmp = list(map(int, tmp)) -> 123 + sum(tmp)  """

def _2231():
    N = int(input()) # 입력: 가장 작은 생성자를 구할 수
    
    for i in range(1, N + 1): # 가장 작은 생성자니까 1부터 찾기 시작
        tmp = [j for j in str(i)] # 각 자리수를 더하기 위해 하나하나 리스트에 추가시켜놓음 (아직은 문자열)
        tmp = list(map(int, tmp)) # 정수로 바꿔줌
        
        if i + sum(tmp) == N: # 이번 차례의 수와 그의 각 자리수까지 모두 더함 -> 이게 이번 차례의 수가 되면 생성자 맞음
            print(i) # 출력: 이를 출력하면 끝
            return
        
    print(0) # 출력: N까지 검사했는데 없으면 0을 출력


#================================================================================================================================================================


"""  2292번 - 벌집
1 / 2 3 4 5 6 7 (6*1) / 8 9 10 11 ... 19 (6*2) / ... -> 4번까지 간다면 최소 2개를 지남, 10번까지 간다면 최소 3개를 지남  """

def _2292():
    N = int(input()) # 입력: 도착하는 방의 번호
    num = 1 # 거쳐가는 방의 번호
    cnt = 1 # 지나야하는 방의 최소 개수
    
    while num < N:
        num += 6 * cnt
        cnt += 1
    
    print(cnt) # 출력: 최소 개수를 출력


#================================================================================================================================================================


"""  2798번 - 블랙잭
; N장의 카드가 주어짐 (최소 3장 최대 100장) -> 여기서 3장을 뽑아서 모두 더함 -> M을 넘지 않으면서 최대한 가깝게 만들어야 함 -> 어떤 3장을 뽑으면 될까? 이때 실제로 그들의 합은?
; 서로 다른 N개에서 순서 상관없이 3개를 뽑는 경우의 수는 NC3 -> 3중 for문 돌려서 총 NC3번의 합을 검사
정확히 뭘 반복하냐면... 새로운 카드 3장의 합을 구함 -> 이게 M을 안 넘으면 이전까지의 최댓값과 비교 -> 더 큰 값을 기록해나감  """

def _2798():
    N, M = map(int, input().split()) # 입력: 카드의 개수, 타겟의 숫자
    card_list = list(map(int, input().split())) # 입력: 카드에 적혀있는 숫자들
    sum = 0 # 3중 for문으로 한번씩 구한 카드 3장의 합 (총 NC3번)
    res = 0 # 타겟을 넘지 않으면서 가장 가까운 합을 기록
    
    for i in range(N):
        for j in range(i + 1, N):
            for k in range(j + 1, N):
                sum = card_list[i] + card_list[j] + card_list[k] # 이번 차례의 카드 3장의 합
                if sum <= M: # 이게 타겟을 안 넘는다면 이전까지의 최댓값과 비교해서 업데이트
                    res = max(res, sum)
    
    print(res) # 출력: 그렇게 구한 최댓값


#================================================================================================================================================================


"""  10250번 - ACM 호텔
; 먼저 호텔의 구조는 다음과 같음
각 층은 1차원 구조로 W개의 방들이 왼쪽부터 연속적으로 이어져 있음 -> 그렇게 1층부터 H층까지 존재 (방은 총 WxH개)
호수는 1층 3번째 방은 103호, 12층 12번째 방은 1212호 이런식으로 지음 (W, 그니까 각 층의 방의 개수는 두자리수(99)까지로만 제한)
; 손님들을 배정하는 방법은... 그냥 쉽게말해 결국에는 101호 201호 ... H01호 -> 102호 202호 ... H02호 -> W01호 W02호 ... W(0)H호 
"""

def _10250():
    T = int(input()) # 입력: 테스트 케이스의 개수
    
    for _ in range(T):
        H, W, N = map(int, input().split()) # 입력: 전체 층의 개수, 각 층마다 동일한 방의 개수, 방에다 배정할 손님
        
        # ex. H, N is 4, 4 -> if N is 9 then 103호, if N is 16 then 404호
        h = N % H # 배정할 방의 층수
        w = N // H + 1 # 배정할 방의 호수
        if h == 0: # 가장 높은 층의 가장 오른쪽 방이 될 경우 (사실상 받을 수 있는 마지막 손님인거)
            h, w = H, w-1
        
        print(h*100 + w) # 출력: 방 번호를 만들어서 출력


#================================================================================================================================================================


"""  15829번 - Hashing
; 알파벳 소문자 a~z를 자연수 1~26으로 매핑 -> abba는 수열 1221
; 그니까 지금 뭐하라는 거냐면...
임의 개수의 알파벳 소문자가 주어짐 -> 각 알파벳을 자연수로 바꾸고 첫번째 알파벳부터 각각 31의 0승, 1승, ...을 곱해줌
그리고 이들을 모두 더한 다음 1234567891로 나눈 나머지를 구함 -> 이를 출력해주면 완료
; ord(a) = 97, ord(b) =98, ... -> ord(알파벳)-96으로 자연수로 변환 O  """

def _15829():
    str_len = int(input()) # 입력: 문자열의 개수
    hash_input = list(input()) # 입력: 알파벳 소문자로만 이루어진 문자열
    
    hash_output = 0
    for i in range(str_len):
        processing = (ord(hash_input[i]) - 96) * (31 ** i)
        hash_output += processing
    
    hash_output %= 1234567891
    print(hash_output) # 출력: 해당 알고리즘에 따라 계산한 수


#================================================================================================================================================================


"""  1259번 - 팰린드롬수
; 앞에서 읽나 뒤에서 읽나 같은 수가 팰린드롬수 -> 121 12421 (O), 123 1231 (X)
10 이런건 010이라고 하면 맞긴 한데 이렇게 맨앞에 무의미한 0은 올수 없다고 가정
; 어떻게 해당 수가 회문인지 확인? 맨앞인 str(수)[0]부터 맨뒤인 str(수)[-1]부터 한 숫자씩 같은 수인지 확인  """

def _1259():
    while True:
        num = int(input()) # 입력: 회문인지 확인할 수
        if num == 0: # 0이 입력되면 종료
            break
        
        num = str(num) # if num = input() and input 0 -> num == '0' isnt working 
        front, rear = 0, -1 # 맨앞의 숫자를 지정, 맨뒤의 숫자를 지정
        check = 'yes' # 회문여부를 저장
        
        for _ in range(len(num) // 2):
            if num[front] != num[rear]:
                check = 'no'
                break
            front += 1
            rear -= 1
        
        print(check) # 출력: 회문여부를 출력


#================================================================================================================================================================


"""  2609번 - 최대공약수와 최소공배수
; 두개의 자연수를 입력받음 -> gcd와 lcm을 구해서 출력
; gcd는 유클리드 호제법으로 구함 -> 자연수 a와 b에 대해, gcd(a, b)는 gcd(b, a % b)와 같고, 계속 반복하다가 a % b가 0이 되면, 그때의 b가 바로 gcd
lcm은 gcd를 응용해서 구함 -> 자연수 a와 b에 대해, a = gcd(a, b) * A, b = gcd(a, b) * B, lcm은 a*b / gcd(a, b)  """

def _2609():
    def gcd(a, b):
        while b > 0:
            a, b = b, a % b
        return a
    
    def lcm(a, b):
        return a * b // gcd(a, b)
    
    a, b= map(int, input().split()) # 입력: gcd와 lcm을 구할 두 수
    print(gcd(a, b)) # 출력: 구한 gcd
    print(lcm(a, b)) # 출력: 구한 lcm 


#================================================================================================================================================================


"""  2775번 - 부녀회장이 될테야
; a층 b호에 산다 == a-1층 1호부터 b호까지 사는 사람들 수의 합만큼 데려와서 살아야 함
0층부터 있음, 각 층에는 1호부터 있음, 0층 n호에는 n명이 있음 / 비어있는 호는 없음, 모든 사람들이 위의 규칙을 지킴 -> 이때 k층 n호에 사는 사람들 수는?
;     1호 2호   3호        4호   ...  | n호
0층   1    2     3          4         | n
1층   1  1+2  1+2+3   1+2+3+4     | n(n+1)/2
2층   1   4     10         20
그니까 k-1층 n호에 사는 사람들 수가 an이라면, k층 n호에 사는 사람들 수는 ∑(k=1~n)ak
; 예를 들어 2층 4호... [1 2 3 4] -> [1 3 6 10] -> [1 4 10 20] -> 20을 출력  """

def _2775():
    T = int(input()) # 입력: 테스트 케이스의 개수
    
    for _ in range(T):
        k = int(input()) # 입력: 몇 층인지
        n = int(input()) # 입력: 몇 호인지
        
        # 일단 0층으로 초기화 -> arr = [1 2 3 4]
        resident_list = [i for i in range(1, n+1)]
        
        # 층수만큼 반복하면서 각 층에 사는 사람들 수를 arr에 갱신
        # 1회: arr = [1, 3, 6, 10] -> 모든 층 1호에는 1명만 사니까 arr[1]~arr[n-1]만 조작
        # 2회: arr = [1, 4, 10, 20] -> arr[-1]을 출력하면 정답
        for _ in range(k):
            for i in range(1, n):
                resident_list[i] += resident_list[i-1]

        print(resident_list[-1]) # 출력: 마지막 요소가 k층 n호에 사는 사람들 수
