# 하계방학 중 동아리 활동 2주차 과제 제출입니다.
import sys, math
input = sys.stdin.readline


#================================================================================================================================================================


"""  5086번 - 배수와 약수
; 두 수 x와 y를 입력받음 -> x가 y의 약수면 factor, x가 y의 배수면 multiple, 둘 다 아니면 neither을 출력 -> 둘 다 0이면 종료  """

def _5086():
    while True:
        x, y = map(int, input().split()) # 두 수를 입력받음
        
        if x == 0 and y == 0: # 둘 다 0이면 종료
            break
        
        # 두 수가 같은 경우는 없다고 했으니까 등호 필요 X
        if x < y: # 전자가 후자보다 작아야 약수 가능
            if y % x == 0: # 나누어 떨어지면 약수임
                print("factor")
            else:
                print("neither")
        elif x > y: # 전자가 후자보다 커야 배수 가능
            if x % y == 0: # 나누어 떨어지면 배수임
                print("multiple")
            else:
                print("neither")


#================================================================================================================================================================


"""  1037번 - 약수
; 어떤 수의 진짜 약수의 개수가 주어짐 -> 진짜 약수들이 주어짐 -> 이로부터 그 어떤 수를 역으로 찾기
여기서 진짜 약수란... A가 N의 진짜 약수라면 A는 1과 N이 아니면서 N을 온전히 나눔  """

def _1037():
    N = int(input()) # 진짜 약수의 개수
    divisor_list = list(map(int, input().split())) # 진짜 약수들
    
    max_num = max(divisor_list) # 가장 큰 수를 찾음
    min_num = min(divisor_list) # 가장 작은 수를 찾음
    
    print(max_num * min_num) # 그 둘을 곱하면 어떤 수


#================================================================================================================================================================


"""  2609번 - 최대공약수와 최소공배수
; 어떤 두 수 x와 y가 주어짐 -> 이들의 gcd와 lcm을 구하기  
gcd는... math.gcd(x, y)해도 되지만 원래대로라면 유클리드의 호제법을 직접 구현 
gcd(x, y) = gcd(y, x%y) -> 예를 들어 gcd(15, 4) = gcd(4, 3) = gcd(3, 1)
lcm은... math.lcm(x, y)해도 되지만 일단 x와 y의 gcd를 k라고 하면 x = k*a, y = k*b
x*y = k*k*a*b -> k가 두 수의 최대공약수였으니 a와 b는 서로소 -> x와 y의 lcm은 x*y // k  """

def _2609():
    x, y = map(int, input().split()) # gcd와 lcm을 구할 두 수
        
    def gcd(x, y): # gcd를 구하는 함수
        while y != 0:
            x, y = y, x % y
        return x
    
    def lcm(x, y): # lcm을 구하는 함수
        return x * y // gcd(x, y)

    print(gcd(x, y))
    print(lcm(x, y))


#================================================================================================================================================================


"""  1934번 - 최소공배수
; 어떤 두 수 A와 B가 주어짐 -> 이들의 lcm을 구함 -> 이런 과정을 주어진 테스트 케이스의 횟수만큼 반복
아마... 위에서는 math 모듈 사용이 목적, 이 문제에서가 gcd, lcm 함수를 직접 작성이 목적  """

def _1934():
    T = int(input()) # 테스트 케이스의 횟수
    
    for _ in range(T):
        A, B = map(int, input().split()) # lcm을 구할 두 수
        
        def gcd(x, y): # gcd를 구하는 함수
            while y != 0:
                x, y = y, x % y
            return x
    
        def lcm(x, y): # lcm을 구하는 함수
            return x * y // gcd(x, y)
        
        print(lcm(A, B))


#================================================================================================================================================================


# 실패
"""  2981번 - 검문
; 총 N개의 수가 주어짐 -> 각각을 M으로 나눴을 때 나머지가 모두 같게 되는 M을 찾기 (1보다 커야 함, 여러개일 수 있음)
음... 일단 N이 2라고 치고... x mod M = y mod M -> x-y mod M = 0
아 그럼 어떤 리스트에 N 다 갖다 박고 차례차례 빼서 새로운 리스트를 만듦 (그 전에 오름차순 정렬도)
상한선은 최대공약수가 될 것... 이보다 더 큰 수로는 나눠봤자 나머지가 같을 수가 없음...
그러면 최소 2부터 최대공약수까지 하나씩 키워나가면서... 만약 이번 차례의 수가 최대공약수를 온전히 나눈다면...
이것도 모든 N들의 공약수니까 나머지가 모두 0으로 같게 돼서 M이 될 수 있음...
"""

def _2981():
    N = int(input())
    num_list = [int(input()) for _ in range(N)]
    num_list.sort()
    
    diff_list = [num_list[i+1] - num_list[i] for i in range(N-1)]
    max_divisor = diff_list[0]
    for i in range(1, len(diff_list)):
        max_divisor = math.gcd(max_divisor, diff_list[i])
    
    res_set = set()
    for i in range(2, max_divisor + 1):
        if max_divisor % i == 0:
            res_set.add(i)

    res_list = list(res_set)
    res_list.sort()
    print(*res_list)
        
_2981()

#================================================================================================================================================================


"""  3036번 - 링
; 총 N개의 링이 주어짐 -> 이들은 모두 접해 있음 -> 첫번째 링을 돌리면 나머지 링들도 연쇄적으로 돌아감 -> 첫번째 링이 한바퀴 돌 동안 나머지 링들은 각각 몇 바퀴를 돔? 
예를 들어 첫번째 링의 반지름이 12일 때 -> 반지름이 3인 링은 4/1바퀴, 반지름이 8인 링은 3/2바퀴, 반지름이 4인 링은 3/1바퀴
이게 일단 A/B 형태인데... 12하고 3, 12하고 8, 12하고 4의 gcd는 각각 3, 4, 4
4/1바퀴는 (12/3)/(3/3)인 것 같고, 3/2바퀴는 (12/4)/(8/4), 3/1바퀴는 (12/4)/(4/4)
; 정리하면 첫번째 링의 반지름과 인접해있는 특정 링의 반지름의 gcd를 구함 -> 출력은 기약분수 형태인데
전자는 첫번째 링의 반지름을 구한 gcd로 나눈 것, 후자는 특정 링의 반지름을 gcd로 나눈 것 -> 그냥 이런식으로 쭉 출력해주면 끝...?  """

def _3036():
    N = int(input()) # 링의 개수
    radius_list = list(map(int, input().split())) # 링의 반지름들

    for i in range(1, N): # 첫번째 링을 제외한 링의 개수만큼 반복
        gcd = math.gcd(radius_list[0], radius_list[i]) # 첫번째 링의 반지름과 인접해있는 특정 링의 반지름의 gcd를 구함
        deno, numer = radius_list[0] // gcd, radius_list[i] // gcd # 각각의 반지름을 방금 구한 gcd로 나눔
        radius_list[i] = str(deno) + '/' + str(numer) # 기약분수 형태로 만들어줌
    
    for i in range(1, len(radius_list)):
        print(radius_list[i])


#================================================================================================================================================================


"""  11050번 - 이항 계수 1
; 어떤 두 수 N과 K가 주어짐 -> 단순히 NCK만 계산하면 됨
nCr의 계산 방법을 생각해보면... nPr/r! = n!/r!(n-r)! = n(n-1)...(n-r+1)/r! 여기서 두번째 공식으로 계산 ㄱㄱ  """

def _11050():
    N, K = map(int, input().split()) # 조합을 계산할 두 수
    
    def fac(N): # 팩토리얼을 계산하는 함수 (반복적으로 구현)
        res = 1
        for i in range(2, N+1): 
            res *= i
        return res

    deno, numer = fac(N), fac(K) * fac(N - K) # 분자는 N!, 분모는 K!(N-K)!
    res = deno // numer # 그렇게 NCK를 계산
    print(res)


#================================================================================================================================================================


"""  11051번 - 이항 계수 2
; 어떤 두 수 N과 K가 주어짐 -> 단순히 NCK % 10007만 계산하면 됨 (???)  
일단 위의 문제에서 마지막에 % 10007만 추가한 후 시간초과 뜨면 다시 생각  """

def _11051():
    N, K = map(int, input().split()) # 조합을 계산할 두 수
    
    def fac(N): # 팩토리얼을 계산하는 함수 (반복적으로 구현)
        res = 1
        for i in range(2, N+1): 
            res *= i
        return res

    deno, numer = fac(N), fac(K) * fac(N - K) # 분자는 N!, 분모는 K!(N-K)!
    res = deno // numer % 10007 # 그렇게 NCK % 10007을 계산
    print(res)


#================================================================================================================================================================


"""  1010번 - 다리 놓기
; N은 서쪽에 있는 사이트의 개수, M은 동쪽에 있는 사이트의 개수
N ≤ M, 한 사이트에는 하나의 다리만 연결, 다리끼리 겹쳐질 수 없음, 총 N개의 다리를 짓는 경우의 수는?
; 사실상 서로 다른 M개에서 N개를 뽑는 조합의 수와 같음 -> M이 더 크니까 그 중 N개를 뽑기만 하면 알아서 다리들이 연결 -> MCN은 M!/N!(M-N)!로 계산할 것 """

def _1010():
    T = int(input()) # 다리 놓기를 진행할 횟수
    
    def factorial(N): # 팩토리얼을 계산하는 함수 (반복적으로 구현)
        res = 1
        for i in range(2, N+1): 
            res *= i
        return res

    for _ in range(T):
        N, M = map(int, input().split()) # 서쪽과 동쪽의 사이트의 개수
        deno, numer = factorial(M), factorial(N) * factorial(M - N) # 분자는 M!, 분모는 N!(M-N)!
        res = deno // numer # 그렇게 MCN을 계산
        print(res)


#================================================================================================================================================================


"""  9375번 - 패션왕 신해빈
; 해빈이는 총 n개의 의상을 가지고 있음 -> 각 의상의 이름과 종류가 연속적으로 주어짐
예를 들어 n이 3일 때 hat - headgear, sunglasses - eyewear, turban - headgear (전자가 이름 후자가 종류)
; 같은 종류의 의상은 존재 O, 같은 이름의 의상은 존재 X -> 최소한 한 의상은 입어야 함, 같은 종류의 의상은 하나만 입을 수 있음
이때 해빈이가 입고 나갈 수 있는 경우의 수를 구함 -> 같은 과정을 주어진 테스트 케이스의 횟수만큼 반복
; 어차피 이름은 안 필요할 것 같고... my_dict = {headgear: 2, eyewear: 1}
headgear의 경우 hat과 turban이 있는데... hat만 선택, turban만 선택, 둘 다 선택 안함... 각 종류마다 이런식으로 경우가 나뉘니까...
각 종류(키)마다 값에 +1씩 한 담에 이들을 모두 곱함 -> 암것도 선택 안하는 경우 1을 빼줌 -> 이대로 출력 끝?  """

def _9375():
    T = int(input()) # 테스트 케이스의 횟수
    
    for _ in range(T):
        n = int(input()) # 의상의 개수
        clothes_dict = {}
        
        for _ in range(n):
            name, kind = input().split() # 의상의 이름과 종류
            if kind in clothes_dict: # 같은 종류의 의상이 있으면
                clothes_dict[kind] += 1 # 개수를 카운트
            else: # 처음 등장한 의상인거면
                clothes_dict[kind] = 1 # 딕셔너리에 새로 추가
        # clothes_dict = {headgear: 2, eyewear: 1}
        
        res = 1
        clothes_list = list(clothes_dict.values()) # 값들만 모두 모음
        for i in clothes_list: # 각각의 값에 +1씩 해서 모두 곱함
            res =  res * (i + 1)

        print(res - 1) # 의상을 하나도 안 입는 경우는 제외


#================================================================================================================================================================


"""  1676번 - 팩토리얼 0의 개수 
; 어떤 수 N이 주어짐 -> N!을 계산함 -> 뒤에서부터 처음으로 0이 아닌 숫자가 나올 때까지 0의 개수를 세기  
음 그럼 str(N!) 후에 list(저거).reverse() -> 하나씩 꺼내서 0이면 개수 +1 -> 그러다 0이 아니면 출력하고 루프 탈출  """

def _1676():
    def fac(N): # N!을 계산하는 함수
        res = 1
        for i in range(2, N+1): 
            res *= i
        return res
    
    N = int(input()) # 팩토리얼을 계산할 수
    res = fac(N) # fac 함수를 통해 N!을 계산함
    res = list(str(res)) # 그 결과 그대로 숫자 하나씩 뜯어서 문자열로 만들어서 리스트에 저장
    res.reverse() # 그 리스트를 거꾸로 뒤집음
    
    cnt = 0 # 0의 개수
    for i in res:
        if i == '0':
            cnt += 1
            continue
        print(cnt)
        break


#================================================================================================================================================================


# 실패 (시간초과)
"""  2004번 - 조합 0의 개수
; 어떤 두 수 n과 m이 주어짐 -> nCm을 계산함 -> 뒤에서부터 처음으로 0이 아닌 숫자가 나올 때까지 0의 개수를 세기
조합은 n!/r!(n-r)!으로 계산 -> 그 다음부터는 위의 문제와 동일 -> 근데 시간초과...  """

def _2004():
    def fac(N): # N!을 계산하는 함수
        res = 1
        for i in range(2, N+1): 
            res *= i
        return res
        
    n, m = map(int, input().split()) # 조합을 계산할 두 수
    deno, numer = fac(n), fac(m) * fac(n-m) # 분자는 n! 분모는 m!(n-m)!
    res = deno // numer # 그렇게 nCm을 계산함
    res = list(str(res)) # 사실상 여기서부터는 이전 문제와 동일
    res.reverse()
    
    cnt = 0 # 0의 개수
    for i in res:
        if i == '0':
            cnt += 1
            continue
        print(cnt)
        break

